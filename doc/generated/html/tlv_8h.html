<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>AP Service Publisher: tlv.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>tlv.h File Reference</h1>This helps you to create and parse a nested type-length-value packet. The value is aligned at 4 octets (32 bits) boundary. When creating a nested TLV packet, the inner part has to be created before the enclosing part. Once the enclosing part has been created, the created inner part can be freed since the chunks have been copied into the enclosing part. See tlv_test.c for a demonstration on how to create a nested TLV packet.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;stdint.h&gt;</code><br>

<p>
<a href="tlv_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlv__chunk.html">tlv_chunk</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tlv_8h.html#d36cab94944bfd82311ae5939d58af94">VALUE_ALIGNMENT</a>&nbsp;&nbsp;&nbsp;(sizeof (uint32_t))</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structtlv__chunk.html">tlv_chunk</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tlv_8h.html#5ba090432b02ce67c02f72f9085218f1">create_chunk</a> (uint32_t type, uint32_t length, const void *value, const struct <a class="el" href="structtlv__chunk.html">tlv_chunk</a> *prev_chunk, void **data, uint32_t *data_len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <a class="el" href="structtlv__chunk.html">tlv_chunk</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tlv_8h.html#105aee4b67b59d78ef45af545ae33ab3">read_chunk</a> (const void *data, uint32_t len, const struct <a class="el" href="structtlv__chunk.html">tlv_chunk</a> *prev_chunk)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="tlv_8h.html#60f430c53515617b8de64cca59ff9006">get_padded_length</a> (uint32_t length, uint32_t aligned_at)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This helps you to create and parse a nested type-length-value packet. The value is aligned at 4 octets (32 bits) boundary. When creating a nested TLV packet, the inner part has to be created before the enclosing part. Once the enclosing part has been created, the created inner part can be freed since the chunks have been copied into the enclosing part. See tlv_test.c for a demonstration on how to create a nested TLV packet. 
<p>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="d36cab94944bfd82311ae5939d58af94"></a><!-- doxytag: member="tlv.h::VALUE_ALIGNMENT" ref="d36cab94944bfd82311ae5939d58af94" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VALUE_ALIGNMENT&nbsp;&nbsp;&nbsp;(sizeof (uint32_t))          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The alignment of the value of a TLV chunk. <dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="tlv__test_8c-example.html#a2">tlv_test.c</a>.</dl>
</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="5ba090432b02ce67c02f72f9085218f1"></a><!-- doxytag: member="tlv.h::create_chunk" ref="5ba090432b02ce67c02f72f9085218f1" args="(uint32_t type, uint32_t length, const void *value, const struct tlv_chunk *prev_chunk, void **data, uint32_t *data_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtlv__chunk.html">tlv_chunk</a>* create_chunk           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structtlv__chunk.html">tlv_chunk</a> *&nbsp;</td>
          <td class="paramname"> <em>prev_chunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>data_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function wraps the pointer arithmetic, the dynamic memory allocation and byte-order conversions for <a class="el" href="structtlv__chunk.html">tlv_chunk</a> fields. At the start of creating a chunk, prev_chunk must be NULL while the other parameters are set properly. The returned object then is kept using a pointer and supplied as prev_chunk for the next chunk creation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>type</em>&nbsp;</td><td>the type of the TLV chunk in host byte order. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>the length of the value in bytes in host byte order. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>the value of the TLV chunk. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>prev_chunk</em>&nbsp;</td><td>the previously created chunk. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>a pointer to the dynamically allocated memory space containing the whole created chunks (the created chunks can then be freed by freeing this pointer). </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>data_len</em>&nbsp;</td><td>The total size in bytes of the created chunks will be stored here.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the created chunk or NULL if there is an insufficient memory. </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="tlv__test_8c-example.html#a3">tlv_test.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="60f430c53515617b8de64cca59ff9006"></a><!-- doxytag: member="tlv.h::get_padded_length" ref="60f430c53515617b8de64cca59ff9006" args="(uint32_t length, uint32_t aligned_at)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t get_padded_length           </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>aligned_at</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates the padded length of unaligned data.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>the length of unaligned data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>aligned_at</em>&nbsp;</td><td>the desired alignment.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the padded length of the unaligned data that is divisible by the alignment. </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="tlv__test_8c-example.html#a1">tlv_test.c</a>.</dl>
</div>
</div><p>
<a class="anchor" name="105aee4b67b59d78ef45af545ae33ab3"></a><!-- doxytag: member="tlv.h::read_chunk" ref="105aee4b67b59d78ef45af545ae33ab3" args="(const void *data, uint32_t len, const struct tlv_chunk *prev_chunk)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtlv__chunk.html">tlv_chunk</a>* read_chunk           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structtlv__chunk.html">tlv_chunk</a> *&nbsp;</td>
          <td class="paramname"> <em>prev_chunk</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function wraps the pointer arithmetic needed to read the chunks in a TLV packet. At the start of parsing a chunk, prev_chunk must be NULL while chunk and chunk_len are set properly. For parsing the next chunk, prev_chunk must be to the last parsed chunk. In all cases, the data and len should be the same so that the parser knows when to stop parsing.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>the start of the data containing TLV chunks. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>len</em>&nbsp;</td><td>the length of the data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>prev_chunk</em>&nbsp;</td><td>the last chunk read.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a parsed chunk or NULL if the end of the data containing the chunks has been reached. </dd></dl>
<dl compact><dt><b>Examples: </b></dt><dd>
<a class="el" href="tlv__test_8c-example.html#a4">tlv_test.c</a>.</dl>
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Feb 18 20:40:40 2010 for AP Service Publisher by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
